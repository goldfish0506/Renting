#开发日志

1. 如果mongoose无法控制数据库大小，那么就只控制数据条数，大约 5000条数据 = 1MB
2. 但是Redis我必须要知道当前已存入大小，因为一旦快到达极限（我还要知道极限大小），我要对缓存进行淘汰
3. 冷启动怎么办？
    - 因为都有冷启动，所以没有关系？
    - 记录每一次的请求概率，把表答应出来


#由来

无论是使用Redis还是仅仅在程序中使用一个hash/object类型的变量，在读写缓存的时候都没有太大的区别（好吧，如果是node.js，那么一个javascript的字符串类型务必会比一个redis使用的字节数更多）

区别之一在于如果缓存数据超过或达到限制，我们应该如何处理，

**如果是Redis你应该没有太大选择，只是在它给出的基于LRU的maxmemory-policy中四选一**

我的疑问是Redis的缓存更新算法一定是最适合自己业务的吗？

页面置换算法（缓存淘汰算法）有非常多的选择

而如果是用自己的语言存在内存中，你可以自己写缓存更新算法。

**淘汰算法使用的好坏会影响缓存的命中率**

如果Redis只是作为缓存的容器的话，它依据什么来更新缓存？至少有三种选择

1. Expire time 给每一个缓存数据设置过期时间

2. Redis 所使用的内存大小

3. 更新算法(LRU, LFU)

有如下感想

**LRU，LFU算法，以及他们的变种，都有自己擅长的地方，擅长的业务逻辑。并非是每一种业务的缓存数据都需要过期时间。过期时间只适用于实时性比较强的数据，可能存在于数据库不一致的地方。对一些存取之后就不用关心的数据（比如搜索引擎搜索结果），过期时间则一点都不重要；**


如何衡量一个缓存的好坏（优化缓存的目标）

- （提高）命中率

**命中率 = 直接从缓存中读取次数 / 请求的次数 = 在缓存中尽可能保留高热度数据 = 淘汰缓存算法尽可能的淘汰冷门数据**

- 时间？空间？

*我相信*不同的算法能面对的场景是不同的，如何找到最适合自己业务的算法？

**机器学习算法——找到最适合自己业务的算法**

机器需要学习什么样的算法，最终应该选择什么样的算法？依据是——命中率

但我是否应该多考虑一条因素：数据数量（内存？）

**不同的算法是否在不同级的数量上的效率也是不一致的？**

**我的设想是随着数量级的增加4000,8000,80000，差距只会正比例增长**

**但非常有可能会出现反比例增长的情况（测试）**

#测试

如何进行测试

随机不断的ping，但是有几个关键词的ping的频率会更高(模拟热词)，比较在一定时间之后，不同算法的效率

最后还要和Redis自带的LRU算法进行比较，看我们的效率有多高

#想到的几个问题

1. 如何触发Redis执行淘汰？超过最大可用内存（以MB为单位）？还是以数据个数为单位？
1MB = ?条数据

答：始终不让Redis触发，监控内存使用情况，当接近极限时，按条数截断

2. 如何模拟多个大数据库？使用多个Collection？Master？C4000？C8000?

#表

##MongoDB

- id
- title
- link

##Redis
```
HASH DB: + id { title: title }
              { link:: link }
```

```
ZSETS DBCache   score   member
```

score值为权值，比如在LFU中，score代表F
                而在LDU中，score代表D

如何记录命中率？每一种算法应该有自己对应的命中率，存于Redis中


```
HASH DB: + 算法名称 { capacity（数据容量）:  }
                    { receive（收到请求数）: }
                    { hits（命中次数） }                 

ZSETS HitRate: { 算法名称：算法命中率 （命中次数 / 收到请求数） }
```


# 机器学习算法

假设我要从六个算法中挑选出最佳的算法，那么每一轮这六个算法都要执行一遍

- 那么这每个算法执行多久才进入下一个算法？200000个请求？

- 一共要执行多少轮才行？100轮？每轮根据命中率选出该轮的最佳算法

# 开始执行

- 每次开始时，我要创建一个branch Collection，从Master复制一定数量的document到branch

究竟要控制几个变量？

1. 缓存容量？因为算法的效率会因为容量的大小不同而发生变化
2. 算法

3.实际数据库容量？这个应该不需要吧

